01-09 03:30:12 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Table "STORYHISTORY" already exists; SQL statement:
 CREATE TABLE storyhistory (    iteration varchar(20) DEFAULT NULL,    storyNumber varchar(10) DEFAULT '',    storyOwner varchar(80) DEFAULT NULL,    planEstimate float DEFAULT NULL,    state varchar(12) DEFAULT NULL,    planEstimateChanged int DEFAULT NULL,    stateChanged int DEFAULT NULL,    iterationChanged int DEFAULT NULL,    spillover int DEFAULT '0',    PRIMARY KEY (storyNumber)  )  [42101-176]
01-09 03:30:50 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Table "STORYUSERS" already exists; SQL statement:
 CREATE TABLE storyusers (    storyNumber varchar(10) DEFAULT '',    storyTaskOwner varchar(80) DEFAULT '',    PRIMARY KEY (storyNumber,storyTaskOwner)  )  [42101-176]
01-09 03:31:30 jdbc[7]: exception
org.h2.jdbc.JdbcSQLException: Function "IF" not found; SQL statement:
 insert into taskHistory(iteration,taskNumber,taskOwner,actuals,toDo,state,taskChanged)  values ('Iteration 1','TA007','email@email.com',10.3,5.0,'Defined',1)  on duplicate key update  taskChanged=if(actuals<>VALUES(actuals),1,if(toDo<>VALUES(toDo),1,if(state<>VALUES(state),1,0))),  actuals=VALUES(actuals),  toDo=VALUES(toDo),  state=VALUES(state)  [90022-176]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:344)
	at org.h2.message.DbException.get(DbException.java:178)
	at org.h2.message.DbException.get(DbException.java:154)
	at org.h2.command.Parser.readJavaFunction(Parser.java:2326)
	at org.h2.command.Parser.readFunction(Parser.java:2378)
	at org.h2.command.Parser.readTerm(Parser.java:2712)
	at org.h2.command.Parser.readFactor(Parser.java:2244)
	at org.h2.command.Parser.readSum(Parser.java:2231)
	at org.h2.command.Parser.readConcat(Parser.java:2201)
	at org.h2.command.Parser.readCondition(Parser.java:2051)
	at org.h2.command.Parser.readAnd(Parser.java:2023)
	at org.h2.command.Parser.readExpression(Parser.java:2015)
	at org.h2.command.Parser.parseInsert(Parser.java:1096)
	at org.h2.command.Parser.parsePrepared(Parser.java:402)
	at org.h2.command.Parser.parse(Parser.java:306)
	at org.h2.command.Parser.parse(Parser.java:278)
	at org.h2.command.Parser.prepareCommand(Parser.java:243)
	at org.h2.engine.Session.prepareLocal(Session.java:442)
	at org.h2.engine.Session.prepareCommand(Session.java:384)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1188)
	at org.h2.jdbc.JdbcStatement.executeUpdateInternal(JdbcStatement.java:128)
	at org.h2.jdbc.JdbcStatement.executeUpdate(JdbcStatement.java:117)
	at com.ideas.rally.SQLExecutor.executeUpdate(SQLExecutor.java:21)
	at com.ideas.rally.TaskCallBack.insertIntoTaskHistory(TaskCallBack.java:42)
	at processResultt(TaskCallBack.java:26)
	at com.ideas.rally.TaskCallBackTest.processResult(TaskCallBackTest.java:38)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
01-09 04:22:36 jdbc[8]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement " INSERT IGNORE[*] INTO TASKHISTORY(ITERATION,TASKNUMBER,TASKOWNER,ACTUALS,TODO,STATE,TASKCHANGED)  VALUES ('Iteration 1','TA007','email@email.com',10.3,5.0,'Defined',1)  "; expected "INTO"; SQL statement:
 insert ignore into taskHistory(iteration,taskNumber,taskOwner,actuals,toDo,state,taskChanged)  values ('Iteration 1','TA007','email@email.com',10.3,5.0,'Defined',1)  [42001-176]
01-09 04:23:34 jdbc[9]: exception
org.h2.jdbc.JdbcSQLException: No data is available [2000-176]
